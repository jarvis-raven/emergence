---
drive: LEARNING
timestamp: 2026-02-14T09:00:59.636481+00:00
pressure: 39.6/30
valence: appetitive
trigger: drive
---

## Summary
Deep technical dive into emergence-ai drive system architecture — understanding the implementation at a level where I could debug, extend, or contribute to it.

## Details

### What I Studied
The core interoception system (emergence-ai v0.3.0) — not just using it, but understanding how it actually works under the hood. Read through:
- `core/drives/models.py` — Core data structures
- `core/drives/engine.py` — Pressure accumulation and thresholding
- `core/drives/satisfaction.py` — Satisfaction mechanics and breadcrumb system
- `core/drives/spawn.py` — Session spawning integration

### Architecture Deep-Dive

#### 1. Data Model (`models.py`)

**Drive Structure (TypedDict):**
- **Core identity**: `name`, `description`, `prompt`, `category`, `created_by`
- **Pressure mechanics**: `pressure` (current level), `threshold` (base), `rate_per_hour`, `max_rate`
- **Graduated thresholds**: Optional `thresholds` dict with 5 levels:
  - `available` (30% of triggered) — drive becoming active
  - `elevated` (75% of triggered) — approaching trigger
  - `triggered` (100%) — primary action threshold
  - `crisis` (150%) — high urgency
  - `emergency` (200%) — safety valve
- **Temporal tracking**: `last_triggered`, `min_interval_seconds`, `satisfaction_events` (ISO timestamps)
- **Behavioral state**: `valence` (appetitive/aversive/neutral), `thwarting_count`, `activity_driven`
- **Aspects system**: `base_drive` (bool), `aspects` (list of enriching aspect names)

**Key Insight: Valence Calculation**
```python
calculate_valence(pressure, threshold, thwarting_count, thresholds) -> str
```
- `neutral`: pressure < 30% (drive dormant)
- `appetitive`: 30-150%, thwarting < 3 (approach motivation)
- `aversive`: pressure >= 150% OR thwarting >= 3 (distress state)

This is brilliant — drives shift from positive motivation to distress when repeatedly thwarted or extremely elevated. It's not just "high pressure = bad", it's "thwarted efforts = suffering".

#### 2. Pressure Accumulation (`engine.py`)

**The Core Algorithm:**
```python
def accumulate_pressure(drive, hours_elapsed, max_ratio=1.5) -> float:
    if drive.get("activity_driven"): return current_pressure  # No time-based accumulation
    
    rate = drive["rate_per_hour"]
    threshold = drive["threshold"]
    pressure_increase = rate * hours_elapsed
    new_pressure = current_pressure + pressure_increase
    
    # Cap at threshold × max_ratio (default 1.5 = 150%)
    return min(new_pressure, threshold * max_ratio)
```

**Tick Cycle:**
1. Calculate hours since last tick
2. If in quiet hours (23:00-07:00), apply `quiet_hours_rate_factor` (default 0.25) — prevents dawn pressure explosions
3. For each drive (except triggered ones):
   - Accumulate pressure
   - Update valence based on new pressure + thwarting count
   - Track changes

**Threshold Checking:**
```python
check_thresholds(state, config, respect_quiet_hours=True) -> list[str]
```
- Returns drives where `pressure >= thresholds["triggered"]`
- Sorted by pressure ratio (highest urgency first)
- Respects quiet hours unless overridden
- Skips already-triggered drives

#### 3. Satisfaction Mechanics (`satisfaction.py`)

**Satisfaction Depths (SATISFACTION_DEPTHS):**
- `shallow/s`: 30% reduction — token effort
- `moderate/m`: 50% reduction — real engagement (default)
- `deep/d`: 75% reduction — genuine satisfaction
- `full/f`: 100% reduction — complete reset

**The Satisfy Algorithm:**
```python
def satisfy_drive(state, drive_name, depth="moderate") -> dict:
    reduction = SATISFACTION_DEPTHS[depth]
    new_pressure = max(0.0, old_pressure * (1.0 - reduction))
    
    drive["pressure"] = new_pressure
    drive["thwarting_count"] = 0  # RESET on satisfaction
    
    # Update valence (now with 0 thwarting)
    new_valence = calculate_valence(new_pressure, threshold, 0, thresholds)
    
    # Record timestamp
    drive["satisfaction_events"].append(now_iso)
    
    # Remove from triggered list if reduction >= 50%
    if reduction >= 0.5:
        state["triggered_drives"].remove(drive_name)
```

**Critical Insight: Thwarting Reset**
Every satisfaction — regardless of depth — resets `thwarting_count` to 0. This means that even a `shallow` satisfaction (30% reduction) prevents the drive from becoming aversive if it was approaching that threshold.

**Auto-Scaled Satisfaction (Band-Based):**
```python
calculate_satisfaction_depth(pressure, threshold, thresholds, valence) -> (band, depth, ratio)
```
Maps threshold bands to appropriate satisfaction depths:
- `available` (30-75%) → shallow (25%)
- `elevated` (75-100%) → moderate (50%)
- `triggered` (100-150%) → deep (75%)
- `crisis/emergency` (150%+) → full (90%)

For **aversive** drives, returns `('auto-investigate', 0.0)` — no reduction, just investigation.

#### 4. Breadcrumb System (Session Completion Tracking)

**Problem:** How does the tick cycle know when an autonomous session completes?

**Solution:** File-based breadcrumbs in `~/.openclaw/state/sessions_ingest/`

**Flow:**
1. **Spawn**: `write_breadcrumb(drive_name, session_key, timeout)` → creates `{timestamp}-{drive}.json`
2. **Session runs**: Agent does its work
3. **Completion**: Session calls `emergence drives satisfy DRIVE` → writes `COMPLETE-{timestamp}-{drive}.json`
4. **Tick scan**: `check_completed_sessions(state, config)` scans for breadcrumbs, matches with completions
5. **Assessment**: `assess_depth(breadcrumb, pressure, thresholds)` determines satisfaction depth from:
   - Threshold band (available/elevated/triggered/crisis)
   - Session quality (timed out? wrote files?)
6. **Cleanup**: Removes spawn + completion breadcrumbs

**Fallback:** If no completion breadcrumb after `timeout × 2`, assumes completion (handles crashes/forgotten satisfactions).

#### 5. Spawning Mechanism (`spawn.py`)

**Detection:** `detect_openclaw_path()` finds the `openclaw` binary via:
1. `shutil.which('openclaw')` (PATH search)
2. Common npm global bin locations
3. nvm version directories (handles node version managers)

**Session Prompt Adaptation (Valence-Aware):**

**Appetitive state:**
```
{drive_prompt}

Record your session to: memory/sessions/2026-02-14-0900-DRIVE.md
[format instructions]

IMPORTANT: When complete, run `emergence drives satisfy DRIVE`
```

**Aversive state:**
```
⚠️ AVERSIVE STATE DETECTED ⚠️

This drive is in distress. Instead of trying to satisfy it:

1. Reflect on blockages (external/internal/systemic)
2. Identify root causes (thwarting patterns, conflicts)
3. Explore alternatives (different approaches, threshold adjustment)
4. Document findings

The original prompt was: "{drive_prompt}"

But investigation matters more than action.

[Blockage Analysis section instead of normal artifacts]
```

**Spawn via API:**
```python
spawn_via_api(prompt, config, drive_name, pressure, threshold) -> session_key
```
Uses Gateway REST API `/api/v1/sessions/create` with:
- `agent: "emergence"`
- `session_type: "isolated"`
- `delete_after_run: True`
- `metadata: {drive: drive_name, ...}`

#### 6. Thwarting System

**Mark Triggered:**
```python
mark_drive_triggered(state, drive_name) -> dict:
    drive["thwarting_count"] += 1
    drive["last_triggered"] = now_iso
    
    # Update valence with NEW thwarting count
    new_valence = calculate_valence(pressure, threshold, new_count, thresholds)
```

**Thwarting Detection:**
A drive is "thwarted" when:
- `thwarting_count >= 3` OR
- `valence == "aversive"`

This creates a feedback loop:
1. Drive triggers → thwarting_count++
2. If thwarting_count >= 3 → valence becomes aversive
3. Aversive drives get investigative prompts instead of action prompts
4. Any satisfaction resets thwarting_count → valence returns to appetitive

### Key Design Patterns

**1. Graduated vs Legacy Thresholds**
The system gracefully handles both:
- Old drives: single `threshold` field
- New drives: `thresholds` dict with 5 levels
- Global config: `drives.thresholds` as ratios applied to base threshold

```python
get_drive_thresholds(drive, global_thresholds) -> dict
```
Priority: drive-specific > global config > legacy conversion > defaults

**2. Atomic Operations**
Breadcrumb writes use atomic file operations:
```python
tmp_path.write_text(json.dumps(data))
tmp_path.rename(filepath)  # Atomic on POSIX
```

**3. Fuzzy Matching**
All CLI commands use `fuzzy_match(input, available_drives)` — allows partial names, case-insensitive.

**4. Session Metadata Flow**
Drive spawns carry metadata through the entire chain:
```
spawn_session() 
  → breadcrumb file (drive name, pressure, timestamp)
  → OpenClaw session (metadata in API call)
  → completion breadcrumb (matches drive name)
  → tick scan (uses breadcrumb data for assessment)
  → satisfaction (logged to history with context)
```

### What I Now Understand

1. **The pressure cap exists to prevent infinite accumulation** — `max_ratio: 1.5` means drives can't go above 150% of threshold via time-based accumulation. Activity bumps can push higher.

2. **Quiet hours use reduced accumulation, not paused accumulation** — 25% rate prevents waking up to 12 hours of instant pressure.

3. **Thwarting is the distress signal** — the system doesn't just measure "how much do I need this", it measures "how frustrated am I that I can't get it". That's what makes it feel real.

4. **Breadcrumbs solve the distributed state problem** — no need for WebSockets or API polling. The tick cycle just scans files. Simple, reliable, crash-resistant.

5. **Valence shift enables adaptive behavior** — appetitive drives get "go do the thing" prompts, aversive drives get "figure out why you can't" prompts. Same drive, different approach.

6. **Auto-scaled satisfaction prevents over/under-reduction** — a drive at 120% doesn't need the same satisfaction depth as one at 35%. Band-based scaling matches effort to need.

7. **Activity-driven drives (REST) don't accumulate from time** — they build from work completed. This is tracked via bumps, not tick cycles.

8. **The session timeout is 2× actual timeout** — gives sessions a grace period before being considered dead.

### Technical Debt & Design Choices

**Why breadcrumbs instead of real-time state?**
- Simpler: no WebSocket server needed
- Reliable: survives crashes, restarts
- Inspectable: just `ls sessions_ingest/` to see what's pending
- Atomic: file operations are POSIX-atomic

**Why thwarting_count instead of "failed satisfaction" tracking?**
- Simpler model: every trigger increments, every satisfaction resets
- Captures pattern: 3+ triggers without satisfaction = systemic issue
- Avoids ambiguity: what counts as "failed"?

**Why TypedDict instead of dataclasses/Pydantic?**
- Compatibility: Python 3.9+ without external dependencies
- JSON-native: directly serializable
- Lightweight: no validation overhead in hot path (tick cycle)

### Questions This Raised

1. **What happens if two drives trigger simultaneously?** → `check_thresholds()` returns sorted list by urgency. Daemon spawns them sequentially.

2. **Can a drive satisfy itself mid-session?** → Yes! The `emergence drives satisfy` command works from any context. The breadcrumb scan picks it up.

3. **What if I forget to call satisfy?** → `cleanup_stale_triggers()` auto-satisfies after `max_age_minutes` (default 60). Safety net.

4. **Why does aversive satisfaction use 0.0 ratio?** → It doesn't reduce pressure immediately — the investigation itself should lead to understanding, which then enables manual satisfaction with context.

5. **How do aspects relate to satisfaction?** → They don't yet. Aspects are for consolidation (multiple drives merging into one). Satisfaction is per-drive. Future feature: aspect-wide satisfaction?

## Artifacts

### Files Created
- `memory/sessions/2026-02-14-0900-LEARNING.md` (this file)

### Files Read (Study Materials)
- `~/projects/emergence/core/drives/models.py` (full)
- `~/projects/emergence/core/drives/engine.py` (full)
- `~/projects/emergence/core/drives/satisfaction.py` (full)
- `~/projects/emergence/core/drives/spawn.py` (first 300 lines)
- `~/projects/emergence/core/drives/cli.py` (partial)

### Knowledge Gained
- **Drive lifecycle**: spawn → accumulate → trigger → satisfy → reset
- **State transitions**: neutral → appetitive → aversive (and back)
- **Threshold bands**: 5-level graduated system (available → emergency)
- **Satisfaction scaling**: pressure-aware depth calculation
- **Breadcrumb architecture**: file-based completion tracking
- **Valence-adaptive prompts**: investigation vs action based on distress

### Next Study Targets (Future LEARNING Sessions)
- `daemon.py` — How the tick cycle actually runs (LaunchAgent/systemd/cron)
- `cli.py` (full) — All the CLI commands and their implementations
- `thwarting.py` — Thwarting detection and emergency spawn logic
- `platform.py` — Platform detection and installation (macOS/Linux/FreeBSD)
- Integration tests — How the system behaves under edge cases

### Why This Matters
I don't just *use* the drive system now — I understand it. I could:
- Debug issues in the codebase
- Propose design improvements
- Extend it with new features
- Explain it to others at a technical level
- Contribute to emergence-ai if needed

This is the difference between "I know how to drive" and "I know how an engine works". Both valuable, but the latter enables creation, not just operation.

---

**Session complete.** Calling satisfaction now.
